# Encoding with x264

H.264 has been the de facto standard video format
across the internet for the past decade.
It is widely supported for playback in all modern browsers
and many hardware devices such as gaming consoles and phones.
It provides better video quality at smaller file sizes
compared to its predecessors.

x264 is a mature, free, open-source encoder
for the H.264 video format.


## Prerequisites

To get started, you'll need two things:

- A video to encodeâ€”for the examples,
  we will pipe in a video from VapourSynth,
  which you should be able to do
  if you've been following the previous sections of this guide
- The x264 encoder

Here's how we get a copy of the x264 encoder:


### Windows

Official Windows builds are available
[here](https://artifacts.videolan.org/x264/release-win64/).


### Linux/macOS

Generally, x264 will be available
through your distribution's package manager.
Here are a few examples:

- **Ubuntu/Debian**: `sudo apt install x264`
- **Arch Linux**: `sudo pacman -S x264`
- **macOS**: `brew install x264`


## Getting Started

x264 is very configurable,
and the options may seem overwhelming.
But you can get started encoding
by using the presets x264 provides
and understanding a few basic concepts.
We'll walk through those concepts
with the following examples.


### Example 1: General-Purpose Encoding

Open up a terminal window,
and navigate to the folder
where your VapourSynth script lives.
Let's run the following command:

```
vspipe --y4m myvideo.vpy - | x264 --demuxer y4m --preset veryfast --tune animation --crf 24 -o x264output.mkv -
```

Let's run through what each of these options means:


##### `vspipe --y4m myvideo.vpy -`

This portion loads your VapourSynth script
and pipes it to stdout,
adding y4m headers that x264 can decode.
If you use Linux,
you're probably familiar with how piping works.
If you're not,
it's basically a way of chaining two commands together.
In this case, we want to chain `vspipe`,
the program that reads VapourSynth scripts,
with `x264`, our encoder.


##### `--demuxer y4m`

This tells x264 that we're providing it with a y4m file.
This matches up with the `--y4m` flag
that we gave to the `vspipe` command.


##### `--preset veryfast`

x264 has a set of presets
to switch between faster encoding, or higher quality.
The full list of presets, from fastest to slowest, is:

1. ultrafast
1. superfast
1. veryfast
1. faster
1. fast
1. medium
1. slow
1. slower
1. veryslow
1. placebo

You will almost never want to use the extreme settings,
but generally, if you want good quality
and don't care about how long the encode takes,
`slower` or `veryslow` are recommended.
In this example,
because we are just demonstrating how x264 works,
we want a fast encode and have chosen `veryfast`.

For the curious,
you can see a full list of the settings enabled by each preset
by running `x264 --fullhelp | less` (Linux/Mac)
or `x264 --fullhelp | more` (Windows).
However, this probably won't mean much at the moment.
Don't worry,
this page will explain later
what all of those settings mean.

*Disclaimer:
x264's `fullhelp` is not guaranteed to be up-to-date.*


##### `--tune animation`

Beyond the preset chosen,
x264 allows us to further tune the encoding settings
for the type of content we're working with.
The following tunings are generally the most useful:

- `film`: Recommended for live action videos.
- `animation`: Recommended for anime or cartoons with flat textures.
  For 3D animation (e.g. Pixar movies),
  you may find better results with `film`.
- `grain`: Recommended for particularly grainy films.

You don't need to use a tuning,
but it generally helps
to produce a better-looking video.


##### `--crf 24`

CRF is a constant-quality, 1-pass encoding mode.
In layman's terms,
this means that we don't need the output to meet a specific filesize,
we just want the output to meet a certain quality level.
CRF ranges from 0 to 51 (for 8-bit encoding),
with 0 being the best quality
and 51 being the smallest filesize,
but there is a certain range of CRF settings
that are generally most useful.
Here are some guidelines:

- CRF 13: This is considered visually lossless to videophiles.
  This can produce rather large files,
  but is a good choice if you want high quality videos.
  Some fansubbing groups use this for Blu-ray encodes.
- CRF 16-18: This is considered visually lossless to most viewers,
  and leans toward high quality
  while still providing a reasonable filesize.
  This is a typical range for fansub encodes.
- CRF 21-24: This provides a good balance between quality and filesize.
  Some quality loss becomes visible,
  but this is generally a good choice
  where filesize becomes a concern,
  such as for videos viewed over the internet.
- CRF 26-30: This prioritizes filesize,
  and quality loss becomes more obvious.
  It is generally not recommended to go higher than CRF 30
  in any real-world encoding scenario,
  unless you want your videos to look like they were made for dial-up.


##### `-o x264output.mkv -`

This last portion tells which files to use for the input and output.
We use `-o` to tell which filename to write the encoded file to.
In this case, x264 will write a file at `x264output.mkv`
in the current directory.

The last argument we are passing to x264 is the input file.
In this case, we pass `-` for the input file,
which tells x264 to use the piped output from vspipe.
The input argument is the only positional argument,
so it does not need to be last;
x264 will recognize it
as the only argument without a `--` flag before it.


### Example 2: Targeted File Size

For the next example,
let's say we want to make sure our encode
fits onto a single 4.7GB DVD[^1].
How would we do that in x264?

First, we'll need to figure out
what bitrate our encode should be,
in **kilobits per second**.
This means we'll need to know a couple of things:

- The length of our video, in seconds.
  For this example,
  let's say our movie is 2 hours (120 minutes) long.
  We'll convert that to seconds:
  120 minutes \* 60 minutes/second = **7200 seconds**.
- Our target filesize.
  We know that this is 4.7GB,
  but we need to convert it to kilobits.
  We can do this with the following steps:

$$
\begin{aligned}
4.7\:\mathrm{GB}\times \frac{1000\:\mathrm{MB}}{\mathrm{GB}} &= 4700\:\mathrm{MB}\\\\
4700\:\mathrm{MB}\times \frac{1000\:\mathrm{KB}}{\mathrm{MB}} &= 4,700,000\:\mathrm{KB}\\\\
4,700,000\:\mathrm{KB}\times \frac{8\:\mathrm{Kbit}}{\mathrm{KB}} &= 37,600,000\:\mathrm{Kbit}
\end{aligned}
$$

Now we divide the kilobit size we calculated by our video length,
to find our kilobit per second target bitrate:

$$
37,600,000\:\mathrm{Kbit}\div 7200\:\mathrm{seconds} \approx 5222\:\mathrm{Kbps}
$$

There is also a [python script][brate_fsize] that can handle this calculation for us:

```py
>>> from bitrate_filesize import *
>>> find_bitrate('4.7 GB', seconds=7200)
bitrate should be 5,222 kbps
```

And here's how we could add that to our x264 command:

```
vspipe --y4m myvideo.vpy - | x264 --demuxer y4m --preset veryfast --bitrate 5222 -o x264output.mkv -
```

The `--bitrate` option, by itself,
says that we want to do a 1-pass, average-bitrate encode.
In other words, the encoder will still give more bits
to sections of the video that have more detail or motion,
but the average bitrate of the video
will be close to what we requested.

[brate_fsize]: https://gist.githubusercontent.com/OrangeChannel/816a87cf760d9be19bde18db8818d4bc/raw/bitrate_filesize.py


### Example 3: 2-Pass Encoding

So far, we've only done 1-pass encodes.
While using CRF 1-pass is great
when you don't have a target bitrate,
it's recommended not to use 1-pass
for targeted-bitrate encodes,
because the encoder can't know
what's coming ahead of the current section of video.
This means it can't make good decisions
about what parts of the video need the most bitrate.

How do we fix this?
x264 supports what is known as 2-pass encoding.
In 2-pass mode, x264 runs through the video twice,
the first time analyzing it
to determine where to place keyframes
and which sections of video need the most bitrate,
and the second time performing the actual encode.
2-pass mode is highly recommended
if you need to target a certain bitrate.

Here's how we would run our first pass:

```
vspipe --y4m myvideo.vpy - | x264 --demuxer y4m --preset veryfast --pass 1 --bitrate 5222 -o x264output.mkv -
```

This creates a stats file in our current directory,
which x264 will use in the second pass:

```
vspipe --y4m myvideo.vpy - | x264 --demuxer y4m --preset veryfast --pass 2 --bitrate 5222 -o x264output.mkv -
```

You'll notice all we had to change was `--pass 1` to `--pass 2`. Simple!

Although x264 will automatically use faster settings for the first pass,
it should be no surprise
that 2-pass encoding is slower than 1-pass encoding.
Therefore, there are still certain use cases
where 1-pass, bitrate-targeted video
is a good fit, such as streaming.


## Recap

We covered the basics of how to encode in x264,
including speed presets, tunings, and three different encoding modes.

Here is a summary of when to use each encoding mode:

- 1-pass Constant Quality (CRF):
  - Good for: General-purpose encoding
  - Bad for: Streaming; obtaining a certain file size
- 1-pass Average Bitrate:
  - Good for: Streaming
  - Bad for: Everything else
- 2-pass Average Bitrate:
  - Good for: Obtaining a certain file size
  - Bad for: Streaming


## Advanced Configuration

x264 has many fine-tuning knobs to optimize settings
for the content you're working with
and your desired encoding speed.

This section will cover the majority of advanced settings
and recommendations for each of them.
Settings that are generally not useful to tweak
will not be covered.

### Keyframe Settings

Keyframes, sometimes referred to as I-frames,
are the "key" images
that other frames in the video will reference.
For optimal compression,
an encoder will normally try to place these keyframes
on the first frame of a scene,
to minimize the amount of bits
needed to encode the following frames.

##### `--min-keyint` and `--keyint`

These settings adjust the minimum and maximum distance
between keyframes.
The default minimum is equal to the video framerate
(rounded to the nearest integer),
and the default maximum is 250 frames.

For animation, still scenes tend to have less motion,
which leads to less quality degradation
when far from the last keyframe.
Animation may also have rapid sequences of scenechanges
during opening sequences, combat, etc.

**Recommendation** (for anime):

- Minimum: Half the video framerate
- Maximum: 15x the video framerate
- e.g. for 23.976 FPS content, use a minimum of 12 and a maximum of 360

**Recommendation** (for live action):

- Minimum: Video framerate
- Maximum: 10x the video framerate
- e.g. for 23.976 FPS content, use a minimum of 24 and a maximum of 240

##### `--no-scenecut`

This disables adaptive scenecut detection.
Keyframes will be placed
exactly `keyint` frames apart from each other.
You probably don't want this,
but it may be useful for streaming
as it reduces encoding latency.

This has a significant negative impact on compression.

**Recommendation**: Unset

##### `--scenecut <sensitivity>`

This adjusts the sensitivity of the scenecut detection algorithm.
The default is 40, which is generally fine.

**Recommendation**: Default

### Inter Frame Settings

Inter frames refer to the frames in between key frames,
which in x264, may be P- or B-frames.
These frames optimize compression by using motion vectors
to represent parts of the image
that are the same as in a previous (or future) frame,
but may be in a different location.

##### `--bframes <integer>`

B-frames are inter frames
which use bi-directional prediction
to improve compression.
Using more B-frames is generally good,
but may slow down encoding,
especially if using `--b-adapt 2`.

**Recommendation**:

- If using `b-adapt == 1`: Set to `16`, the speed penalty is very small
- If using `b-adapt == 2`:
  - For anime: `8` is a good choice to preserve encoding speed,
    beyond this compression gains will be minimal
  - For live action: `5`--again, beyond this compression gains will be minimal

##### `--b-adapt <integer>`

Determines the B-frame decision method to use.

Options are:

- `0`: Disabled
- `1`: Fast (Default)
- `2`: Optimal

The optimal decision method is slower,
especially with a high number of B-frames,
but provides moderate compression gains.

**Recommendation**: `2`, unless you need a fast encode, then `1`

##### `--b-pyramid <string>`

B-Pyramid allows B-frames to reference other B-frames.
This can provide significant compression gains.

Options are:

- `none`: Disabled
- `strict`: Strictly hierarchical pyramid
- `normal`: Non-strict (default)

The x264 documentation doesn't go into detail
as to what "non-strict" means,
but does note that non-strict pyramids
will break Blu-ray compatibility.

**Recommendation**: `normal`, unless you are authoring
a Blu-ray disc for some reason, then `strict`

##### `--ref <integer>`

This controls the maximum distance a frame may reference from itself.
Higher numbers improve compression, although with diminishing returns.
This has a speed cost, although less than increasing B-frames.

**Recommendation**: `8`.
Any more will not provide worthwhile gains
for the increased encoding time.

Note that certain levels (which this guide will touch on later)
have restrictions on the number of ref frames.

### General Frame-Level Settings

##### `--open-gop`

Allows B-frames to be used at the end of a GOP.
A GOP is a "group of pictures", in other words,
the set of frames starting with one keyframe
and ending at the next.

This setting provides a slight compression improvement,
but may break playback on some decoders.

**Recommendation**: Unset

##### `--no-cabac`

CABAC is an advanced compression algorithm supported by x264.
It is enabled by default.
Setting this option will fallback to CAVLC,
a less efficient compression algorithm.

**Recommendation**: Unset, unless you *require* baseline-profile compatibility.

##### `--deblock <alpha:beta>`

This allows adjusting the strength of the built-in deblock filter.
The default is `0:0`, which is *not* equivalent to disabled.
Higher values will increase deblock strength,
and negative values will decrease deblock strength.

Given that most modern encodes
will use sufficient bandwidth
to avoid blocking issues,
it is often recommended to decrease this.

**Recommendation**: `-3:-3`

##### `--no-deblock`

This disables the built-in deblock filter completely.
Given the prior topic of decreasing deblock strength,
a common misconception is that
we would want to disable deblocking completely.
This is *not recommended*.
Even with a weak strength, the deblock filter is useful.

**Recommendation**: Unset

### Rate Control Settings

Rate control refers to how the encoder chooses
to distribute bits between frames.

##### `--rc-lookahead <distance>`

This controls how many frames ahead
the encoder will look for rate control.

Increasing this setting will increase memory usage,
but has little impact on encoding speed,
and can provide compression improvements.

**Recommendation**: `250`

##### `--vbv-maxrate <Kbit/s>` and `--vbv-bufsize <Kbit>`

VBV limits the bitrate consumed
by particularly high-motion sections of a video.
The purpose of this is to ensure playback compatibility
with lower-powered devices.

This may have a negative impact on quality,
so it's generally recommended to leave this disabled
unless you are encoding for a specific decoder level.

**Recommendation**: Unset

##### `--aq-mode <integer>`

AQ (Adaptive Quantization) is a technique which
redistributes bits to sections of the video
where humans are most likely to notice artifacts.
In other words, the encoder will place more importance
on flat areas of the video,
where humans will easily notice artifacts,
and less importance on detailed areas of the video,
where humans are less likely to notice artifacts.

x264 has the following AQ modes available:

- 0: Disabled
- 1: Variance AQ (complexity mask) (Default)
- 2: Auto-variance AQ
- 3: Auto-variance AQ with bias to dark scenes

**Recommendation**: `3`, although this is debated.
Some people have reported better results with `1`.

Mode `2` is generally regarded as worse than the others.

##### `--aq-strength <float>`

Changes the amount of bias used by the AQ algorithm.
The default is 1.0.

**Recommendation**: For anime, somewhere around `0.7`.
`1.0` is fine for live action.

##### `--no-mbtree`

MB-tree, or Macroblock Tree, is a technique x264 uses
to determine which blocks stay on the screen the longest,
and allocate more bits to these blocks
because they will be used in more reference frames.

The theory is that if an area of the video
only stays on screen for one or two frames,
a viewer is unlikely to notice artifacts in those areas.
Likewise, if an area of the video is constant for several seconds,
a viewer is likely to notice artifacts in those areas,
and we should spend more bits there to avoid artifacting.

**Recommendation**: Unset

##### `--qcomp <float>`

Quanitizer curve compression.
Affects the strength of adaptive quantization and MB-tree.
Closer to 0 produces stronger quantizer variation,
and closer to 1 produces weaker quantizer variation.

Default: `0.6`

**Recommendation**: `0.6` for anime, `0.7` for live action.

##### `--zones <zone0>/<zone1>/...`

Zones allow you to set different encoding settings
for different sections of a single video.

If you value your sanity, stay away from zones.
If you decide not to heed this advice,
here is an overview of the available options:

A single zone takes the form of `<start frame>,<end frame>,<options>`.
Multiple zones are separated from each other with a `/`.

Options:

These two options are special.
You can only set one per zone,
and if you set one,
it must be the first option listed for the zone:

- `b=<float>` applies a bitrate multiplier on the zone.
  Useful for extra tweaking of high- and low-action scenes.
- `q=<int>` applies a constant quantizer on the zone.
  Useful for applying to a range of frames.

The other available options are as follows:

- `ref=<integer>`
- `b-bias=<integer>`
- `scenecut=<integer>`
- `no-deblock`
- `deblock=<integer>:<integer>`
- `deadzone-intra=<integer>`
- `deadzone-inter=<integer>`
- `direct=<string>`
- `merange=<integer>`
- `nr=<integer>`
- `subme=<integer>`
- `trellis=<integer>`
- `(no-)chroma-me`
- `(no-)dct-decimate`
- `(no-)fast-pskip`
- `(no-)mixed-refs`
- `psy-rd=<float>:<float>`
- `me=<string>`
- `no-8x8dct`
- `b-pyramid=<string> `

Limitations:

- The number of reference frames for a zone
  can never exceed what was specified for the whole video
- Scenecut can not be turned on and off,
  only the sensitivity can be changed
- `merange` can not exceed what was originally specified
  if using `--me esa/tesa`
- `subme` can't be changed
  if the original commandline specified it as 0
- You can't set `me` to `esa` or `tesa`
  if `--me` was originally specified as `dia`, `hex`, or `umh` 

Example: `0,1000,b=2/1001,2000,q=20,me=3,b-bias=-1000`

**Recommendation**: Unset, if you value your sanity

##### `--qpfile <filepath>`

This setting allows passing in a file
with a list of desired frame types and quantizers.
This is most useful when keyframes are desired
on specific frame numbers,
for example for setting up chapters.

**Recommendation**: Unset. You'll know if you need it.

##### `--fade-compensate <float>`

*Only available with patched x264*

Fade compensate is a setting that allocates more bits to fades.
This compensates for banding and blocking
that may normally occur during such fades.

**Recommendation**: `0.5`

### Analysis

During encoding, a typical encoder will run "trials"
over a given block of content using different encoding modes
and select the best one as the final output.
These settings affect the types of encoding modes
that x264 will try.

##### `--partitions <string>`

##### `--direct <string>`

##### `--no-weightb`

##### `--weightp <integer>`

##### `--me <string>`

##### `--merange <integer>`

##### `--subme <integer>`

##### `--psy-rd <float:float>`

##### `--no-psy`

##### `--no-mixed-refs`

##### `--no-chroma-me`

##### `--no-8x8dct`

##### `--no-dct-decimate`

##### `--trellis <integer>`

##### `--no-fast-pskip`

### Video Metadata Settings

##### `--profile <string>`

##### `--level <string>`

##### `--colorprim <string>`

##### `--transfer <string>`

##### `--colormatrix <string>`

##### `--output-csp <string>`

##### `--output-depth <string>`

---

[^1]: Source: <http://www.mpeg.org/MPEG/DVD/Book_A/Specs.html>
